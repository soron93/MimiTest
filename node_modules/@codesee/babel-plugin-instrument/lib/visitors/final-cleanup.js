"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.finalCleanupVisitor=void 0;var _utils=require("../utils"),_core=require("@babel/core"),finalCleanupVisitor={"FunctionDeclaration|ArrowFunctionExpression|FunctionExpression|ClassMethod|ObjectMethod":{enter:function enter(a){var b=a.get("body.body");if(!Array.isArray(b)){return}var c=b.findIndex(_utils.isStackFrameEnterStatement);if(-1===c){return}if(0!==c){var d=b[c],e=d.node;d.remove();a.get("body").unshiftContainer("body",e)}b=a.get("body.body");var f=b.findIndex(_utils.isFuncInputsStatement);if(-1===f){return}if(1!==f){var g=b.findIndex(function(a,b){if(0===b||b===f){return!1}return(0,_utils.hasCodeSeeTracking)(a)}),h=b[f],i=h.node;h.remove();if(-1===g){console.error("CodeSee Warning: During final cleanup, found a function with StackFrameEnter but no StackFrameExit",a.node);var j=b[b.length-1];j.insertAfter(i)}else{var k=b[g];k.insertBefore(i)}}}},CallExpression:function CallExpression(a){if(a.node.codesee||a.node.tracked)return;if(a.get("callee").isSuper()){var d=a.node;d.tracked=!0;var b=_core.types.stringLiteral((0,_utils.getLocString)(a.node.loc)),c=(0,_utils.findStackFrameIdIdentifier)(a);if(c===void 0){return}var e=_core.types.sequenceExpression([(0,_utils.codeSeeCall)(_core.types,"aboutToCallSuper",[c,b]),(0,_utils.codeSeeCall)(_core.types,"callSuper",[d,c,b])]);e.codesee=!0;a.replaceWith(e)}}};exports.finalCleanupVisitor=finalCleanupVisitor;